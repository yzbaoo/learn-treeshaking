{"ast":null,"code":"'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function (string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n\n  while (match) {\n    const allmatches = [];\n    const len = match.length;\n\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n\n  return matches;\n};\n\nconst isName = function (string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function (v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function (obj) {\n  return Object.keys(obj).length === 0;\n};\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\n\n\nexports.merge = function (target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n\n    const len = keys.length; //don't make it inline\n\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [a[keys[i]]];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\n\nexports.getValue = function (v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n}; // const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\n\nexports.buildOptions = function (options, defaultOptions, props) {\n  var newOptions = {};\n\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n\n  return newOptions;\n};\n/**\n * Check if a tag name should be treated as array\n *\n * @param tagName the node tagname\n * @param arrayMode the array mode option\n * @param parentTagName the parent tag name\n * @returns {boolean} true if node should be parsed as array\n */\n\n\nexports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {\n  if (arrayMode === false) {\n    return false;\n  } else if (arrayMode instanceof RegExp) {\n    return arrayMode.test(tagName);\n  } else if (typeof arrayMode === 'function') {\n    return !!arrayMode(tagName, parentTagName);\n  }\n\n  return arrayMode === \"strict\";\n};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;","map":{"version":3,"names":["nameStartChar","nameChar","nameRegexp","regexName","RegExp","getAllMatches","string","regex","matches","match","exec","allmatches","len","length","index","push","isName","exports","isExist","v","isEmptyObject","obj","Object","keys","merge","target","a","arrayMode","i","getValue","buildOptions","options","defaultOptions","props","newOptions","undefined","isTagNameInArrayMode","tagName","parentTagName","test"],"sources":["/Users/yzbaoo/Desktop/huohua/ilc-web-packages/node_modules/fast-xml-parser/src/util.js"],"sourcesContent":["'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options, defaultOptions, props) {\n  var newOptions = {};\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n  return newOptions;\n};\n\n/**\n * Check if a tag name should be treated as array\n *\n * @param tagName the node tagname\n * @param arrayMode the array mode option\n * @param parentTagName the parent tag name\n * @returns {boolean} true if node should be parsed as array\n */\nexports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {\n  if (arrayMode === false) {\n    return false;\n  } else if (arrayMode instanceof RegExp) {\n    return arrayMode.test(tagName);\n  } else if (typeof arrayMode === 'function') {\n    return !!arrayMode(tagName, parentTagName);\n  }\n\n  return arrayMode === \"strict\";\n}\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}